{"ast":null,"code":"import { isVisible } from '../util/TickUtils';\nimport { getEveryNthWithCondition } from '../util/getEveryNthWithCondition';\nexport function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  var result = (ticks || []).slice();\n  var initialStart = boundaries.start,\n      end = boundaries.end;\n  var index = 0; // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n  // For now, start from every tick\n\n  var stepsize = 1;\n  var start = initialStart;\n\n  while (stepsize <= result.length) {\n    // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n    // If it can not, then increase the stepsize by 1, and try again.\n    var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index]; // Break condition - If we have evaluate all the ticks, then we are done.\n\n    if (entry === undefined) {\n      return getEveryNthWithCondition(ticks, stepsize);\n    } // Check if the element collides with the next element\n\n\n    var size = getTickSize(entry, index);\n    var tickCoord = entry.coordinate; // We will always show the first tick.\n\n    var isShow = index === 0 || isVisible(sign, tickCoord, size, start, end);\n\n    if (!isShow) {\n      // Start all over with a larger stepsize\n      index = 0;\n      start = initialStart;\n      stepsize += 1;\n    }\n\n    if (isShow) {\n      // If it can be shown, update the start\n      start = tickCoord + sign * (size / 2 + minTickGap);\n      index += stepsize;\n    }\n  }\n\n  return [];\n}","map":{"version":3,"names":["isVisible","getEveryNthWithCondition","getEquidistantTicks","sign","boundaries","getTickSize","ticks","minTickGap","result","slice","initialStart","start","end","index","stepsize","length","entry","undefined","size","tickCoord","coordinate","isShow"],"sources":["C:/Users/Ashwini/AndroidStudioProjects/web102_unit7lab-main/teammates/node_modules/recharts/es6/cartesian/getEquidistantTicks.js"],"sourcesContent":["import { isVisible } from '../util/TickUtils';\nimport { getEveryNthWithCondition } from '../util/getEveryNthWithCondition';\nexport function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  var result = (ticks || []).slice();\n  var initialStart = boundaries.start,\n    end = boundaries.end;\n  var index = 0;\n  // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n  // For now, start from every tick\n  var stepsize = 1;\n  var start = initialStart;\n  while (stepsize <= result.length) {\n    // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n    // If it can not, then increase the stepsize by 1, and try again.\n\n    var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index];\n\n    // Break condition - If we have evaluate all the ticks, then we are done.\n    if (entry === undefined) {\n      return getEveryNthWithCondition(ticks, stepsize);\n    }\n\n    // Check if the element collides with the next element\n    var size = getTickSize(entry, index);\n    var tickCoord = entry.coordinate;\n    // We will always show the first tick.\n    var isShow = index === 0 || isVisible(sign, tickCoord, size, start, end);\n    if (!isShow) {\n      // Start all over with a larger stepsize\n      index = 0;\n      start = initialStart;\n      stepsize += 1;\n    }\n    if (isShow) {\n      // If it can be shown, update the start\n      start = tickCoord + sign * (size / 2 + minTickGap);\n      index += stepsize;\n    }\n  }\n  return [];\n}"],"mappings":"AAAA,SAASA,SAAT,QAA0B,mBAA1B;AACA,SAASC,wBAAT,QAAyC,kCAAzC;AACA,OAAO,SAASC,mBAAT,CAA6BC,IAA7B,EAAmCC,UAAnC,EAA+CC,WAA/C,EAA4DC,KAA5D,EAAmEC,UAAnE,EAA+E;EACpF,IAAIC,MAAM,GAAG,CAACF,KAAK,IAAI,EAAV,EAAcG,KAAd,EAAb;EACA,IAAIC,YAAY,GAAGN,UAAU,CAACO,KAA9B;EAAA,IACEC,GAAG,GAAGR,UAAU,CAACQ,GADnB;EAEA,IAAIC,KAAK,GAAG,CAAZ,CAJoF,CAKpF;EACA;;EACA,IAAIC,QAAQ,GAAG,CAAf;EACA,IAAIH,KAAK,GAAGD,YAAZ;;EACA,OAAOI,QAAQ,IAAIN,MAAM,CAACO,MAA1B,EAAkC;IAChC;IACA;IAEA,IAAIC,KAAK,GAAGV,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACO,KAAD,CAA/D,CAJgC,CAMhC;;IACA,IAAIG,KAAK,KAAKC,SAAd,EAAyB;MACvB,OAAOhB,wBAAwB,CAACK,KAAD,EAAQQ,QAAR,CAA/B;IACD,CAT+B,CAWhC;;;IACA,IAAII,IAAI,GAAGb,WAAW,CAACW,KAAD,EAAQH,KAAR,CAAtB;IACA,IAAIM,SAAS,GAAGH,KAAK,CAACI,UAAtB,CAbgC,CAchC;;IACA,IAAIC,MAAM,GAAGR,KAAK,KAAK,CAAV,IAAeb,SAAS,CAACG,IAAD,EAAOgB,SAAP,EAAkBD,IAAlB,EAAwBP,KAAxB,EAA+BC,GAA/B,CAArC;;IACA,IAAI,CAACS,MAAL,EAAa;MACX;MACAR,KAAK,GAAG,CAAR;MACAF,KAAK,GAAGD,YAAR;MACAI,QAAQ,IAAI,CAAZ;IACD;;IACD,IAAIO,MAAJ,EAAY;MACV;MACAV,KAAK,GAAGQ,SAAS,GAAGhB,IAAI,IAAIe,IAAI,GAAG,CAAP,GAAWX,UAAf,CAAxB;MACAM,KAAK,IAAIC,QAAT;IACD;EACF;;EACD,OAAO,EAAP;AACD"},"metadata":{},"sourceType":"module"}